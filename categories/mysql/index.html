<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mysql | Siddon&#39;s Blog</title>
  <meta name="author" content="SiddonTang">
  
  <meta name="description" content="My thought for program">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Siddon&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Siddon&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27956076-1']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Siddon&#39;s Blog</a></h1>
  <h2><a href="/">My thought for program</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/Presentations">Presentations</a></li>
    
      <li><a href="/About">About</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title category">mysql</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-01-03T13:20:27.000Z"><a href="/2015/01/03/mysql-ha/">01-03-2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/03/mysql-ha/">MySQL高可用浅析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>对于多数应用来说，MySQL都是作为最关键的数据存储中心的，所以，如何让MySQL提供HA服务，是我们不得不面对的一个问题。当master当机的时候，我们如何保证数据尽可能的不丢失，如何保证快速的获知master当机并进行相应的故障转移处理，都是需要我们好好思考的。这里，笔者将结合这段时间做的MySQL proxy以及toolsets相关工作，说说我们现阶段以及后续会在项目中采用的MySQL HA方案。</p>
<h2 id="Replication">Replication</h2>
<p>要保证MySQL数据不丢失，replication是一个很好的解决方案，而MySQL也提供了一套强大的replication机制。只是我们需要知道，为了性能考量，replication是采用的asynchronous模式，也就是写入的数据并不会同步更新到slave上面，如果这时候master当机，我们仍然可能会面临数据丢失的风险。</p>
<p>为了解决这个问题，我们可以使用semi-synchronous replication，semi-synchronous replication的原理很简单，当master处理完一个事务，它会等待至少一个支持semi-synchronous的slave确认收到了该事件并将其写入relay-log之后，才会返回。这样即使master当机，最少也有一个slave获取到了完整的数据。</p>
<p>但是，semi-synchronous并不是100%的保证数据不会丢失，如果master在完成事务并将其发送给slave的时候崩溃，仍然可能造成数据丢失。只是相比于传统的异步复制，semi-synchronous replication能极大地提升数据安全。更为重要的是，它并不慢，MHA的作者都说他们在facebook的生产环境中使用了semi-synchronous（<a href="http://yoshinorimatsunobu.blogspot.ca/2014/04/semi-synchronous-replication-at-facebook.html" target="_blank" rel="external">这里</a>），所以我觉得真心没必要担心它的性能问题，除非你的业务量级已经完全超越了facebook或者google。</p>
<p>如果真的想完全保证数据不会丢失，现阶段一个比较好的办法就是使用<a href="http://galeracluster.com/" target="_blank" rel="external">gelera</a>，一个MySQL集群解决方案，它通过同时写三份的策略来保证数据不会丢失。笔者没有任何使用gelera的经验，只是知道业界已经有公司将其用于生产环境中，性能应该也不是问题。但gelera对MySQL代码侵入性较强，可能对某些有代码洁癖的同学来说不合适了:-)</p>
<p>我们还可以使用<a href="http://drbd.linbit.com/" target="_blank" rel="external">drbd</a>来实现MySQL数据复制，MySQL官方文档有一篇文档有详细<a href="http://dev.mysql.com/doc/refman/5.6/en/ha-drbd.html" target="_blank" rel="external">介绍</a>，但笔者并未采用这套方案，MHA的作者写了一些采用drdb的问题，<a href="https://code.google.com/p/mysql-master-ha/wiki/Other_HA_Solutions#Pacemaker_+_DRBD" target="_blank" rel="external">在这里</a>，仅供参考。</p>
<p>在后续的项目中，笔者会优先使用semi-synchronous replication的解决方案，如果数据真的非常重要，则会考虑使用gelera。</p>
<h2 id="Monitor">Monitor</h2>
<p>前面我们说了使用replication机制来保证master当机之后尽可能的数据不丢失，但是我们不能等到master当了几分钟才知道出现问题了。所以一套好的监控工具是必不可少的。</p>
<p>当master当掉之后，monitor能快速的检测到并做后续处理，譬如邮件通知管理员，或者通知守护程序快速进行failover。</p>
<p>通常，对于一个服务的监控，我们采用keepalived或者heartbeat的方式，这样当master当机之后，我们能很方便的切换到备机上面。但他们仍然不能很即时的检测到服务不可用。笔者的公司现阶段使用的是keepalived的方式，但后续笔者更倾向于使用zookeeper来解决整个MySQL集群的monitor以及failover。</p>
<p>对于任何一个MySQL实例，我们都有一个对应的agent程序，agent跟该MySQL实例放到同一台机器上面，并且定时的对MySQL实例发送ping命令检测其可用性，同时该agent通过ephemeral的方式挂载到zookeeper上面。这样，我们可以就能知道MySQL是否当机，主要有以下几种情况：</p>
<ol>
<li>机器当机，这样MySQL以及agent都会当掉，agent与zookeeper连接自然断开</li>
<li>MySQL当掉，agent发现ping不通，主动断开与zookeeper的连接</li>
<li>Agent当掉，但MySQL未当</li>
</ol>
<p>上面三种情况，我们都可以认为MySQL机器出现了问题，并且zookeeper能够立即感知。agent与zookeeper断开了连接，zookeeper触发相应的children changed事件，监控到该事件的管控服务就可以做相应的处理。譬如如果是上面前两种情况，管控服务就能自动进行failover，但如果是第三种，则可能不做处理，等待机器上面crontab或者supersivord等相关服务自动重启agent。</p>
<p>使用zookeeper的好处在于它能很方便的对整个集群进行监控，并能即时的获取整个集群的变化信息并触发相应的事件通知感兴趣的服务，同时协调多个服务进行相关处理。而这些是keepalived或者heartbeat做不到或者做起来太麻烦的。</p>
<p>使用zookeeper的问题在于部署起来较为复杂，同时如果进行了failover，如何让应用程序获取到最新的数据库地址也是一个比较麻烦的问题。</p>
<p>对于部署问题，我们要保证一个MySQL搭配一个agent，幸好这年头有了docker，所以真心很简单。而对于第二个数据库地址更改的问题，其实并不是使用了zookeeper才会有的，我们可以通知应用动态更新配置信息，或者使用proxy来解决。</p>
<p>虽然zookeeper的好处很多，但如果你的业务不复杂，譬如只有一个master，一个slave，zookeeper可能并不是最好的选择，没准keepalived就够了。</p>
<h2 id="Failover">Failover</h2>
<p>通过monitor，我们可以很方便的进行MySQL监控，同时在MySQL当机之后通知相应的服务做failover处理，假设现在有这样的一个MySQL集群，a为master，b，c为其slave，当a当掉之后，我们需要做failover，那么我们选择b，c中的哪一个作为新的master呢？</p>
<p>原则很简单，哪一个slave拥有最近最多的原master数据，就选哪一个作为新的master。我们可以通过<code>show slave status</code>这个命令来获知哪一个slave拥有最新的数据。我们只需要比较两个关键字段<code>Master_Log_File</code>以及<code>Read_Master_Log_Pos</code>，这两个值代表了slave读取到master哪一个binlog文件的哪一个位置，binlog的索引值越大，同时pos越大，则那一个slave就是能被提升为master。这里我们不讨论多个slave可能会被提升为master的情况。</p>
<p>在前面的例子中，假设b被提升为master了，我们需要将c重新指向新的master b来开始复制。我们通过<code>CHANGE MASTER TO</code>来重新设置c的master，但是我们怎么知道要从b的binlog的哪一个文件，哪一个position开始复制呢？</p>
<h3 id="GTID">GTID</h3>
<p>为了解决这一个问题，MySQL 5.6之后引入了GTID的概念，即uuid:gid，uuid为MySQL server的uuid，是全局唯一的，而gid则是一个递增的事务id，通过这两个东西，我们就能唯一标示一个记录到binlog中的事务。使用GTID，我们就能非常方便的进行failover的处理。</p>
<p>仍然是前面的例子，假设b此时读取到的a最后一个GTID为<code>3E11FA47-71CA-11E1-9E33-C80AA9429562:23</code>，而c的为<code>3E11FA47-71CA-11E1-9E33-C80AA9429562:15</code>，当c指向新的master b的时候，我们通过GTID就可以知道，只要在b中的binlog中找到GTID为<code>3E11FA47-71CA-11E1-9E33-C80AA9429562:15</code>这个event，那么c就可以从它的下一个event的位置开始复制了。虽然查找binlog的方式仍然是顺序查找，稍显低效暴力，但比起我们自己去猜测哪一个filename和position，要方便太多了。</p>
<p>google很早也有了一个<a href="https://code.google.com/p/google-mysql-tools/wiki/GlobalTransactionIds" target="_blank" rel="external">Global Transaction ID</a>的补丁，不过只是使用的一个递增的整形，<a href="https://github.com/siddontang/ledisdb" target="_blank" rel="external">LedisDB</a>就借鉴了它的思路来实现failover，只不过google貌似现在也开始逐步迁移到MariaDB上面去了。</p>
<p>MariaDB的GTID实现跟MySQL 5.6是不一样的，这点其实比较麻烦，对于我的MySQL工具集<a href="https://github.com/siddontang/go-mysql" target="_blank" rel="external">go-mysql</a>来说，意味着要写两套不同的代码来处理GTID的情况了。后续是否支持MariaDB再看情况吧。</p>
<h3 id="Pseudo_GTID">Pseudo GTID</h3>
<p>GTID虽然是一个好东西，但是仅限于MySQL 5.6+，当前仍然有大部分的业务使用的是5.6之前的版本，笔者的公司就是5.5的，而这些数据库至少长时间也不会升级到5.6的。所以我们仍然需要一套好的机制来选择master binlog的filename以及position。</p>
<p>最初，笔者打算研究<a href="https://code.google.com/p/mysql-master-ha/" target="_blank" rel="external">MHA</a>的实现，它采用的是首先复制relay log来补足缺失的event的方式，但笔者不怎么信任relay log，同时加之MHA采用的是perl，一个让我完全看不懂的语言，所以放弃了继续研究。</p>
<p>幸运的是，笔者遇到了<a href="https://github.com/outbrain/orchestrator" target="_blank" rel="external">orchestrator</a>这个项目，这真的是一个非常神奇的项目，它采用了一种<a href="http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid" target="_blank" rel="external">Pseudo GTID</a>的方式，核心代码就是这个</p>
<pre><code>create database if not exists meta;

drop event if exists meta.create_pseudo_gtid_view_event;

delimiter ;;
create event if not exists
  meta.create_pseudo_gtid_view_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      set @_create_statement := concat(&#39;create or replace view meta.pseudo_gtid_view as select \&#39;&#39;, @pseudo_gtid, &#39;\&#39; as pseudo_gtid_unique_val from dual&#39;);
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;
    end
;;

delimiter ;

set global event_scheduler := 1;
</code></pre><p>它在MySQL上面创建了一个事件，每隔1s，就将一个uuid写入到一个view里面，而这个是会记录到binlog中的，虽然我们仍然不能像GTID那样直接定位到一个event，但也能定位到一个1s的区间了，这样我们就能在很小的一个区间里面对比两个MySQL的binlog了。</p>
<p>继续上面的例子，假设c最后一次出现uuid的位置为s1，我们在b里面找到该uuid，位置为s2，然后依次对比后续的event，如果不一致，则可能出现了问题，停止复制。当遍历到c最后一个binlog event之后，我们就能得到此时b下一个event对应的filename以及position了，然后让c指向这个位置开始复制。</p>
<p>使用Pseudo GTID需要slave打开<code>log-slave-update</code>的选项，考虑到GTID也必须打开该选项，所以个人感觉完全可以接受。</p>
<p>后续，笔者自己实现的failover工具，将会采用这种Pseudo GTID的方式实现。</p>
<p>在《MySQL High Availability》这本书中，作者使用了另一种GTID的做法，每次commit的时候，需要在一个表里面记录gtid，然后就通过这个gtid来找到对应的位置信息，只是这种方式需要业务MySQL客户端的支持，笔者不很喜欢，就不采用了。</p>
<h2 id="后记">后记</h2>
<p>MySQL HA一直是一个水比较深的领域，笔者仅仅列出了一些最近研究的东西，有些相关工具会尽量在<a href="https://github.com/siddontang/go-mysql" target="_blank" rel="external">go-mysql</a>中实现。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-12-28T10:24:58.000Z"><a href="/2013/12/28/mysql-index-point/">12-28-2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/12/28/mysql-index-point/">MySQL索引研究</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="介绍">介绍</h1>
<p>这段时间在重构server，尤其是重新设计表结构以满足功能需求以及后续的性能需求。因为我们使用的是mysql，所以为了支持更多的并发访问，对大数据量的表设计一些index是必不可少的，而现在看我当时设计的index，又发现了很多不足的地方。同时又因为深入重新在学习了解了一些index知识，觉得有必要记录一下，以免自己再犯同样的错误。</p>
<p>假设有如下的表结构，后续所有的例子都通过该表来说明：</p>
<pre><code>table tbl,
fileid int,
groupid int,
opver int,
name varchar(1024),
entid int,
primary key (fileid),
engine = innodb
</code></pre><h1 id="聚集索引">聚集索引</h1>
<p>因为使用的mysql engine是innodb，所以对于主键使用的是聚簇索引，对于聚簇索引我们知道它是吧数据存放到index里面的，也就是通过主键查询就能直接定位到数据，非常方便。</p>
<p>以前我受到的教育就是，select *是邪恶的，因为会取出所有列的数据。诚然，对于数据的获取，我们是按需索取，这样就能极大的减少网络传输的消耗。正因为以前有这样的认识，我自然认为innodb在server端io数据读取的时候也是按需索取。但其实不是这样。</p>
<p>在innodb里面，数据是按照页来存放的，通常一页为16k，每一页至少存放2条数据，也就是说，每一条数据在最大为8k。这里有童鞋就可能疑惑了，那如果我表结构里面有blob，text这种类型的肿么办？对于这种大数据类型的，innodb会将其存放到一个overflow page里面去，然后数据页只存放对应的指针。同样，innodb也是按照页来读取数据，也就是说一次读取16k。</p>
<p>对于上面我们的表结构，是完全能够存放到同一个page里面的，也就是说，我们即使select的时候没有选择对应的列，在innodb层面也仍然会将该数据读出，也就说无论怎样，io消耗是一样的。具体可以参考<a href="http://www.zhaokunyao.com/archives/1558" target="_blank" rel="external">这篇</a>。</p>
<p>这里在谈谈主键id类型选择的问题，因为innodb采用的是b+tree来进行数据的存储，网上对于是否采用自增id或者guid这种争论满天飞，现在我的想法如下：</p>
<ul>
<li>guid会导致主键过于分散，以至于在数据进行插入，删除，更新的时候会进行b+tree的频繁分裂，同时读取数据的时候因为过于分散会导致io随即读取，性能不高。</li>
<li>自增id虽然能让io进行顺序读取，但是如果服务器数据量太大造成分表了，对于每张表的auto increment的初始值维护也是一件很烦的事情。</li>
<li>鉴于上面那种情况，我们现在考虑的做法就是提供一个id生成器，用来保证主键的顺序递增，同时又保证全局的完全唯一。这个id生成器很容易，使用redis的incr就可以搞定，而且还可以通过incrby进行批量申请，性能妥妥的。</li>
</ul>
<h1 id="联合索引">联合索引</h1>
<p>一般为了查询方便，我们有可能在多列上面建立联合索引，譬如在(groupid, opver)上面，那么我就可以很方便的使用如下索引：</p>
<pre><code>select * from tbl where groupid in (1,2,3)
select * from tbl where groupid = 1 and opver &gt; 10 and opver &lt; 100
select * from tbl where groupid = 1 and opver &gt; 10 order by opver desc limit 10
</code></pre><p>在上面那些查询语句立马，index都能很好的工作，然后我就自认为下面这种的也行：</p>
<pre><code>select * from tbl where groupid in (1,2,3) and opver &gt; 10 order by opver desc limit 10
</code></pre><p>对于这个查询，我自然想到的就是首先mysql会通过索引选出groupid为1，2，3的，然后再在这个结果集里面选出opver满足的进行排序。可真的是这样吗。使用explain之后，才发现，在extra那一栏生生的出现了using filesort。也就是说mysql并没有对opver使用索引进行order by，而是使用了filesort，这里我们的索引在groupid之后就无效了。</p>
<p>其实这种情况可以用通用的情况来归纳，在一个组合索引里面，如果出现了多个范围查询，那么mysql不可能为每一个范围都使用索引，一般碰到第一个范围之后就会停止索引工作了。</p>
<p>这里给了我一个深刻的教训，就是设计好表结构以及index之后，不要自认为就能按照我想的方式工作了，最好需要explain一下，看看mysql到底是怎么工作的，不然出了性能瓶颈都不知道。</p>
<h1 id="覆盖索引">覆盖索引</h1>
<p>当我们需要查询的数据通过索引就能查到的时候，这种索引就叫做覆盖索引。譬如下面这些:</p>
<pre><code>select groupid, opver from tbl where groupid = 1 and opver &gt; 10;

select fileid, groupid, opver from tbl where groupid = 1 and opver &gt; 10 order by opver limit 10
</code></pre><p>因为我们在(groupid, opver)上面建立了索引，那么当我们查询的所有列包含在该索引里面的时候，我们就可以通过覆盖索引直接找到。通过explain可以看到extra里面有using index，表明使用了覆盖索引。</p>
<p>对于第二个例子，为什么fileid也可以使用覆盖索引呢，因为对于innodb来说，非聚簇索引保存的是主键id，也就是fileid，所以通过索引也能够直接找到fileid。</p>
<p>使用覆盖索引的好处是很明显的，数据只需要通过索引就能获取，而不需要通过主键在进行随机的io读取。一个很简单的例子。</p>
<pre><code>select entid from t1 order by opver limit 100000, 10;

select entid from t1 inner join (select fileid from t1 order by opver limit 100000, 10) as ac using(fileid)
</code></pre><p>因为我们需要查询entid，而没有任何一个索引能覆盖entid，这里我们给opver单独建立一个索引。对于第一个查询，mysql因为需要获取entid，所以会通过fileid查到实际的数据并取出，在进行排序，同时因为limit的跨度很大，mysql会丢弃很多数据，所以导致该查询会很慢。</p>
<p>而对于第二个查询，在join立马，我们只是通过覆盖索引找到了fileid，而不需要通过fileid去随机io读取实际数据，取出所有的fileid之后，在取出了entid。虽然该查询有一个join操作，但是因为join的性能很高，所以比第一个查询快很多。</p>
<p>关于索引覆盖，网上有很多关于这个的介绍，譬如<a href="http://hi.baidu.com/shinegun/item/1f36f5517bd8b4dfd48bac2d" target="_blank" rel="external">这个</a>，总之用好了覆盖索引，是能极大提升效率的，但是也不可能为了覆盖索引去建立覆盖索引，如果索引泛滥了，也是一件很头疼的事情。</p>
<h1 id="filesort">filesort</h1>
<p>对于先前联合索引遇到的问题，我发现如果不重新设计整个的查询机制，按照现有做法是完全不能避免filesort的。因为我们的业务逻辑就是需要查询一批groupid里面，opver大于某个值的所有数据。既然避免不了，那我们就可以看看到底性能高不高。</p>
<p>mysql对于filesort，有两种处理方式，一种是单路排序，一种是双路排序。单路排序直接就是取出选择的字段，然后在sort buffer中排序。而双路排序则是取出排序字段以及主键，排序完成之后在通过主键获取实际的数据。可以看出，双路排序会有两次io操作，自然性能会差一点。</p>
<p>早期mysql采用的是双路排序，现在采用的是单路，但是如果我们需要排序的数据超过了配置的sort buffer空间，或者需要排序的单行数据长度大于max_length_for_sort_data，mysql仍然会使用单路排序。mysql默认max_length_for_sort_data为1024，这个需要根据实际数据长度进行配置。</p>
<p>不过如果能把mysql的硬盘换成ssd，或者把内存加到100g以上，我觉得这个filesort也还真不成问题了。</p>
<h1 id="后续">后续</h1>
<p>这几天对于mysql索引的研究就先记录一下，感觉对mysql的理解还需要加深，后续如果还有什么新的感想也会在这里记录。同时bs一下自己，号称用了mysql这么多年，到现在了还有很多东西没有领会，是时候开始好好深入研究了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:siddontang.com">
  </form>
</div>

  <div class="widget tag">
  <h3 class="title">Github</h3>
  <ul class="entry">
  <li><a href="https://github.com/siddontang/ledisdb" target="_blank">LedisDB</a><small>Fast NoSQL</small></li>
  <li><a href="https://github.com/siddontang/mixer" target="_blank">Mixer</a><small>MySQL Proxy with Go</small></li>
  <li><a href="https://github.com/siddontang/libtnet" target="_blank">Libtnet</a><small>High Performance EventLoop</small></li>
  <li><a href="https://github.com/siddontang/moonmq" target="_blank">MoonMQ</a><small>Fast Message Queue</small></li>
  <li><a href="https://github.com/siddontang" target="_blank">More...</a></li>
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/c++/">c++</a><small>7</small></li>
  
    <li><a href="/categories/go/">go</a><small>27</small></li>
  
    <li><a href="/categories/leetcode/">leetcode</a><small>1</small></li>
  
    <li><a href="/categories/lua/">lua</a><small>2</small></li>
  
    <li><a href="/categories/mysql/">mysql</a><small>2</small></li>
  
    <li><a href="/categories/nginx/">nginx</a><small>2</small></li>
  
    <li><a href="/categories/program/">program</a><small>14</small></li>
  
    <li><a href="/categories/python/">python</a><small>6</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/algorithm/" style="font-size: 10.00px;">algorithm</a><a href="/tags/c++/" style="font-size: 18.75px;">c++</a><a href="/tags/celery/" style="font-size: 10.00px;">celery</a><a href="/tags/go/" style="font-size: 20.00px;">go</a><a href="/tags/gopkg/" style="font-size: 10.00px;">gopkg</a><a href="/tags/goroutine/" style="font-size: 10.00px;">goroutine</a><a href="/tags/json/" style="font-size: 10.00px;">json</a><a href="/tags/ledisdb/" style="font-size: 15.00px;">ledisdb</a><a href="/tags/leetcode/" style="font-size: 10.00px;">leetcode</a><a href="/tags/leveldb/" style="font-size: 10.00px;">leveldb</a><a href="/tags/libtnet/" style="font-size: 16.25px;">libtnet</a><a href="/tags/log/" style="font-size: 10.00px;">log</a><a href="/tags/lua/" style="font-size: 13.75px;">lua</a><a href="/tags/message-queue/" style="font-size: 10.00px;">message queue</a><a href="/tags/mixer/" style="font-size: 12.50px;">mixer</a><a href="/tags/moonmq/" style="font-size: 11.25px;">moonmq</a><a href="/tags/mysql/" style="font-size: 17.50px;">mysql</a><a href="/tags/nginx/" style="font-size: 11.25px;">nginx</a><a href="/tags/nosql/" style="font-size: 15.00px;">nosql</a><a href="/tags/polaris/" style="font-size: 11.25px;">polaris</a><a href="/tags/pprof/" style="font-size: 10.00px;">pprof</a><a href="/tags/proxy/" style="font-size: 10.00px;">proxy</a><a href="/tags/python/" style="font-size: 17.50px;">python</a><a href="/tags/reflect/" style="font-size: 10.00px;">reflect</a><a href="/tags/restful/" style="font-size: 10.00px;">restful</a><a href="/tags/rpc/" style="font-size: 10.00px;">rpc</a><a href="/tags/timer/" style="font-size: 11.25px;">timer</a><a href="/tags/timingwheel/" style="font-size: 10.00px;">timingwheel</a><a href="/tags/tornado/" style="font-size: 12.50px;">tornado</a><a href="/tags/zookeeper/" style="font-size: 10.00px;">zookeeper</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 SiddonTang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'siddontang';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>